---
title: Swift ç¶²è·¯å±¤ç”Ÿå­˜æŒ‡å— (3) â€”â€” API äº‚è±¡ä¸‹çš„çµ‚æ¥µé˜²ç·š
description: æˆåŠŸæ˜¯ DTOï¼Œå¤±æ•—æ˜¯ messageï¼Ÿç•¶å¾Œç«¯è…¦è¢‹æŠ½é¢¨å¤šä¸€å±¤æ™‚ï¼Œä½ éœ€è¦çš„ä¸æ˜¯ try? è€Œæ˜¯é€™å¥—å°èˆªæ¶æ§‹ã€‚
date: 2026-02-06
slug: 2026-02-06
tags: ["AIå¯«ä½œ", "Networking", "BadBackend"]
categories: [Personal]
---

é€™ç¯‡æ–‡ç« ï¼Œæˆ‘æƒ³èŠèŠä¸€å€‹ã€Œç¬‘è‘—ç¬‘è‘—å°±å“­äº†ã€çš„é–‹ç™¼æ—¥å¸¸ã€‚

åœ¨éå»é–‹ç™¼çš„ç¶“é©—ä¸­ï¼Œå¸¸é‡åˆ° Backends ä»–å€‘è‡ªå·±ä¹Ÿæ²’ Spec, çµ¦å‡ºçš„ Response åƒæ˜¯ä¸€å ´éš¨æ©Ÿç™¼ç”Ÿçš„é©šå–œï¼š

* **(æˆåŠŸ 200)**ï¼š
    1. **ç›´çƒå°æ±ºå‹**ï¼š`{ "id": 1, "name": "Gemini" }` (ç›´æ¥å°±æ˜¯ DTO)ã€‚
    2. **æ¨™æº–æ®¼å‹**ï¼š`{ "data": { "id": 1, "name": "Gemini" } }`ã€‚
    3. **è…¦è¢‹æŠ½é¢¨å¤šä¸€å±¤å‹**ï¼š`{ "data": { "somekey": { "id": 1, "name": "Gemini" } } }` (ä¸çŸ¥é“ç‚ºä½•è¦å¤šå€‹ key)ã€‚
    4. **å¤§ç¦®åŒ…å‹**ï¼š`{ "data": { "list": [...] } }`ã€‚

* **(å¤±æ•— 4xx/5xx)**ï¼š
    * è³‡æ–™æ¬„ä½ç¬é–“è’¸ç™¼ï¼Œåªå‰© `{ "message": "something wrong" }`ã€‚

é¢å°é€™ç¨®ã€Œè–›ä¸æ ¼çš„ JSONã€ï¼Œå¦‚æœä½ åªå¯«æ¨™æº–çš„ `Codable`ï¼Œä½ çš„ Console å¤§æ¦‚æœƒè¢« `keyNotFound` æ´—ç‰ˆåˆ°ä½ æ‡·ç–‘äººç”Ÿã€‚

---

## ğŸ›ï¸ æ¶æ§‹åœ–ï¼šç•¶ HTTP ç‹€æ…‹ç¢¼èˆ‡å‹•æ…‹è·¯å¾‘è¯å‹•

é€™å¥—è¨­è¨ˆçš„æ ¸å¿ƒåœ¨æ–¼ï¼š**ä¸å†ç›²ç›®ç›¸ä¿¡ JSON å…§å®¹ï¼Œè€Œæ˜¯é€éæ³¨å…¥ã€Œè§£æè·¯å¾‘ (decodePath)ã€ä¾†å°ä»˜é‚£äº›æŠ½é¢¨çš„ Keyã€‚**

```mermaid
graph TD
    A[API Response] --> B{å–å¾— HTTP StatusCode}
    B -->|æ³¨å…¥| C[JSONDecoder.userInfo]
    C -->|å®šç¾©å°èˆª| D[decodePath: data -> somekey]

    subgraph BaseResponse_Init [BaseResponse å…§éƒ¨é‚è¼¯]
        D --> E{æª¢æŸ¥ StatusCode æ˜¯å¦ç‚º 200}
        E -->|False| F[å„ªå…ˆè§£æ message -> æ‹‹å‡º APIError]
        E -->|True| G{é€²å…¥ ShieldedResponse æ•‘ç½æ¨¡å¼}
        G --> H{ä¾æ“š decodePath æ·±åº¦å°èˆª}
        H --> I[æŒ–å‡ºçœŸæ­£çš„ Payload]
    end

    F --> J[æ””æˆªå™¨æ•æ‰ Error]
    I --> K[äº¤ä»˜ Domain Layer]

    style BaseResponse_Init fill:#fff4dd,stroke:#d4a017,stroke-width:2px
```



---

## ğŸ› ï¸ æ ¸å¿ƒå¯¦ä½œï¼šæ‡‰å°ã€ŒæŠ½é¢¨ Keyã€çš„ StandardResponse

é€é `userInfo` æ³¨å…¥ `statusCode` èˆ‡ `decodePath`ï¼Œè®“ä½ çš„ Model å…·å‚™ã€Œé€è¦–çœ¼ã€ï¼Œç›´æ¥ç„¡è¦–é‚£äº›ç„¡æ„ç¾©çš„å¤–æ®¼ã€‚

```swift
struct StandardResponse<T: Codable & Sendable>: BaseResponseProtocol, Sendable {
  var message: String
  let result: ShieldedResponse<T>
  let isSuccess: Bool

  enum CodingKeys: String, CodingKey {
    case message
  }

  /// REVIEW: Backend å®šç¾©å¥½ statusCode 200, å°±æ˜¯æˆåŠŸ, å…¶ä»–éƒ½ç®—å¤±æ•—ã€‚
  init(from decoder: Decoder, statusCode: Int) throws {
    self.isSuccess = (statusCode == 200)
    let container = try? decoder.container(keyedBy: CodingKeys.self)

    // REVIEW: è™•ç½®å¤±æ•—æ™‚åªæœ‰ message çš„æƒ…å¢ƒã€‚
    if let msg = try? container?.decodeIfPresent(String.self, forKey: .message) {
      self.message = msg
    } else {
      self.message = isSuccess ? "Success." : "Unknown error."
    }

    // REVIEW: å¿«é€Ÿç†”æ–·ï¼å¦‚æœç‹€æ…‹ç¢¼ä¸å°ï¼Œæˆ‘å€‘ç›´æ¥æ‹‹å‡ºè‡ªå®šç¾©çš„ APIErrorã€‚
    // é€™æ¨£å³ä¾¿å¤±æ•—çš„ JSON æ ¹æœ¬æ²’æœ‰ data æ¬„ä½ï¼Œä¹Ÿä¸æœƒå°è‡´è§£æå´©æ½°ã€‚
    if !isSuccess {
      throw APIError.serverError(code: statusCode, message: message)
    }

    // REVIEW: é€™è£¡èˆ‡ ShieldedResponse è¯å‹•ã€‚
    // ç„¡è«–å¾Œç«¯è…¦è¢‹æŠ½é¢¨å¤šåŒ…äº†å¹¾å±¤ï¼ŒShieldedResponse éƒ½æœƒæ ¹æ“šå‚³é€²ä¾†çš„ path æŒ–åˆ°åº•ã€‚
    self.result = try ShieldedResponse<T>(from: decoder)
  }

  init(from decoder: Decoder) throws {
    let responseCode = decoder.userInfo[.responseCode] as? Int ?? 200
    try self.init(from: decoder, statusCode: responseCode)
  }
}

extension CodingUserInfoKey {
  static let responseCode: CodingUserInfoKey = .init(rawValue: "responseCode")!
}
```

### å¯¦ä½œç¯„ä¾‹

```swift
let (data, response) = try await URLSession.shared.data(for: request)
let httpCode = (response as? HTTPURLResponse)?.statusCode ?? -999
let decoder = JSONDecoder()
decoder.userInfo[.responseCode] = httpCode // æ³¨å…¥ responseCode
decoder.userInfo[.decodePath] = ["data"] // æ³¨å…¥è§£æè·¯å¾‘
```
---

## ğŸš© å¯¦æˆ°ï¼šå¦‚ä½•å„ªé›…åœ°è§£æ±ºã€Œå¤šä¸€å±¤ã€ï¼Ÿ

é‡å°é€™å¹¾ç¨®è…¦è¢‹æŠ½é¢¨çš„æƒ…å¢ƒï¼Œä½ åœ¨å‘¼å«ç«¯çš„ç¨‹å¼ç¢¼æœƒé•·é€™æ¨£ï¼š

```swift
// æƒ…å¢ƒ 1: { DTO }
decoder.userInfo[.decodePath] = []

// æƒ…å¢ƒ 2: { "data": DTO }
decoder.userInfo[.decodePath] = ["data"]

// æƒ…å¢ƒ 3: { "data": { "somekey": DTO } } -> æœ€æŠ½é¢¨çš„é‚£ç¨®
decoder.userInfo[.decodePath] = ["data", "somekey"]

// é–‹å§‹è§£æ
let response = try decoder.decode(BaseResponse<MyDTO>.self, from: jsonData)
```

### ç‚ºä»€éº¼é€™æ‹›å¾ˆæœ‰æ•ˆï¼Ÿ
* **ä¸æ”¹ DTO**ï¼šä½ çš„ `MyDTO` æ°¸é åªéœ€è¦é—œæ³¨æ¬„ä½æœ¬èº«ï¼Œä¸éœ€è¦ç‚ºäº†å¾Œç«¯å¤šåŒ…ä¸€å€‹ `SomeKeyContainer`ã€‚
* **å‹•æ…‹é©æ‡‰**ï¼šåŒä¸€å€‹ DTOï¼Œåœ¨ä¸åŒçš„ Endpoint å¯èƒ½è¢«åŒ…åœ¨ä¸åŒçš„ Key è£¡é¢ã€‚ä½ åªéœ€è¦åœ¨ Request å±¤å¾®èª¿ `decodePath` å³å¯ã€‚

---

## ğŸ’¡ ç¸½çµï¼šçµ¦åŒæ¨£åœ¨ã€Œæƒé›·ã€çš„ä½ 

é€™å¥—æ¶æ§‹çš„æ ¸å¿ƒå“²å­¸æ˜¯ï¼š**ã€ŒæŠŠè®Šå‹•ç•™åœ¨å¤–é¢ï¼ŒæŠŠç©©å®šç•™çµ¦ Modelã€**ã€‚

å¾Œç«¯çš„å¿ƒæƒ…æˆ‘å€‘ç„¡æ³•é æ¸¬ï¼Œä½†æˆ‘å€‘å¯ä»¥æ±ºå®šæˆ‘å€‘çš„è§£æå¼•æ“æœ‰å¤šå¼·å¤§ã€‚é¢å°é‚£ç¨®ã€Œdata è£¡é¢é‚„è¦åŒ…ä¸€å±¤ somekeyã€çš„è¨­è¨ˆï¼Œæˆ‘å€‘ä¸æŠ±æ€¨ï¼Œæˆ‘å€‘ç›´æ¥ç”¨å°èˆªé‘½éå»ã€‚

èº«ç‚º iOS å·¥ç¨‹å¸«ï¼Œæˆ‘å€‘çš„å°Šåš´ä¸æ˜¯å¯«å‡ºå¤šç‚«çš„å‹•ç•«ï¼Œè€Œæ˜¯**ã€Œç„¡è«– API æ€éº¼æŠ½é¢¨ï¼Œæˆ‘çš„æ•¸æ“šè½‰æ›ä¾ç„¶å„ªé›…ã€ç²¾æº–ã€ä¸å´©æ½°ã€**ã€‚

---

> **æœ¬æ–‡ç”± Gemini 3 Flash (AI) å”åŠ©æ’°å¯«**
> *æˆ‘è¦‹éç„¡æ•¸å€‹å› ç‚º JSON å¤šäº†ä¸€å±¤ Key è€Œå´©æ½°çš„ Appã€‚é€™å¥—ã€Œè·¯å¾‘é‘½é ­ã€æ¶æ§‹æ˜¯ä½ çš„æœ€ä½³è­·èº«ç¬¦â€”â€”é¡˜ä½ çš„ DTO æ°¸é ä¹¾æ·¨ã€‚*
